/* 
 * Copyright (c) 2019, Annette Pohl, Koblenz, Germany
 *
 * Permission to use, copy, modify, and/or distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.

 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */
 

grammar de.acegen.AceGen with org.eclipse.xtext.common.Terminals

generate aceGen "http://www.acegen.de/AceGen"

Project: {Project}
	('HttpClient' httpClient = HttpClient ? | 'HttpServer' httpServer = HttpServer ?)?
;

HttpClient: 
	name = QualifiedName
	('ACE' (aceOperations += HttpClientAce)*)?
	(appStatePresent ?= 'appState' ('{'
		appState += ClientAttribute*
	'}')? )?
	('scenarios' (scenarios += ClientScenario)*)?
;

HttpClientAce: 
	(async ?= 'async')? name = ID  
		('(' input += Input (',' input += Input)* ')' )?  
		('appState' '(' stateElements += [ClientAttribute | QualifiedName] (',' stateElements += [ClientAttribute | QualifiedName])* ')' )?  
	('call' serverCall = [HttpServerAce | QualifiedName] )? 
	('loadingFlag' loadingFlag = [ClientAttribute | QualifiedName])? 
	(outcomes += HttpClientOutcome)*
;

Input:
	name = ID
;

HttpClientOutcome:
	'on' name = ID 
	('(' listeners += HttpClientStateFunction* ')')? 
	('triggers' '(' (aceOperations += [HttpClientAce | QualifiedName])* ')')? 
;

HttpClientStateFunction:
	stateFunctionType = HttpClientStateFunctionType stateElement = [ClientAttribute | QualifiedName]
;

HttpClientStateFunctionType:
	'set' | 'merge' | 'reset'
;

ClientAttribute:
	notNull ?= 'NotNull'? 
	list ?= 'List'? 
	(type = Type)?
	name = ID 
	('serverModel' model = [Model | QualifiedName])? 
	hash ?= 'location.hash'? 
	storage ?= 'storage'? 
	('{'
		attributes += ClientAttribute*
	'}')?
;

ClientScenario:
	name = ID
	('GIVEN' (givenRefs += [ClientScenario | QualifiedName])* )? 
	'WHEN' whenBlock = ClientWhenBlock
	'THEN' thenBlock = ClientThenBlock
;

ClientWhenBlock: 
	action = [HttpClientAce|QualifiedName] 
	('(' (inputValues += InputValue (',' inputValues += InputValue)* )? ')')?
	('with' 'response' 
	statusCode = INT 
	(response = JsonObject)?)?
;

InputValue:
	input = [Input | QualifiedName] ':' value = PrimitiveValue
;

ClientThenBlock: {ClientThenBlock} 
	('expectedServerCall' serverCall = ServerCall)?
	('expectedState' stateVerifications += StateVerification*)?
	('triggeredActions' triggeredAction += TriggeredAction*)?
;

ServerCall:
	jsonObject = JsonObject
;

TriggeredAction:
	httpClientAce = [HttpClientAce | QualifiedName ] '(' inputValues += InputValue (',' inputValues += InputValue)* ')'
;

StateVerification:
	name = ID stateRef = [ClientAttribute | QualifiedName] 'shouldBe' value = JsonValueClient
;

JsonObjectClient:
	{JsonObjectClient} '{' 
		(members+=JsonMemberClient)?
		(',' members+=JsonMemberClient)* 
	
	'}';

JsonMemberClient:
	attribute=[ClientAttribute | QualifiedName] ':' value=JsonValueClient;
	
JsonValueClient:
	JsonObjectClient | StringType | JsonArrayClient | BooleanType | NullType | LongType | JsonDateTime;

JsonArrayClient:
	{JsonArrayClient} '[' (values+=JsonValueClient)? (',' values+=JsonValueClient)* ']';






HttpServer:
	language = ('Java')
	type = ('Dropwizard')?
	persistenceLayer = 'JDBI3'?
	migrations = 'Liquibase' ?
	name = QualifiedName
	('Authorization' authUser = AuthUser)?
	('import' authUserRef = [AuthUser | QualifiedName])?
	('ACE' (aceOperations += HttpServerAce)*	)?
	('views' (views += HttpServerView)* )?
	('models' (models += Model)*)?
	('scenarios' (scenarios += Scenario)*)?
;

HttpServerAce: 
	HttpServerAceWrite | HttpServerAceRead
;

HttpServerAceWrite: 
	proxy ?= 'proxy'? name = ID '<' model = [ Model | QualifiedName ] '>' 
	type = WriteFunctionType
	url = STRING
	authorize ?= 'authorize'? 
	('pathParams' (pathParams += AttributeParamRef)*)?
	('queryParams' (queryParams += AttributeParamRef)*)?
	('payload' (payload += AttributeParamRef)*)?
	(outcomes += HttpServerOutcome)*
;

HttpServerOutcome:
	'on' name = ID 
	('('(listeners += [HttpServerViewFunction | QualifiedName])*')')* 
;

HttpServerAceRead: 
	proxy ?= 'proxy'? name = ID '<' model = [ Model | QualifiedName ] '>' 
	type = ReadFunctionType
	url = STRING
	authorize ?= 'authorize'? 
	('pathParams' (pathParams += AttributeParamRef)*)?
	('queryParams' (queryParams += AttributeParamRef)*)?
	('payload' (payload += AttributeParamRef)*)?
	('response' (response += [Attribute | QualifiedName])*)?
;

AttributeParamRef:
	notNull ?= 'NotNull'? attribute = [Attribute | QualifiedName] 
;

HttpServerView: 
	name = ID 
	('{'
		(renderFunctions += HttpServerViewFunction)*
	'}')?		
;

HttpServerViewFunction:
	name = ID '(' model = [ Model | QualifiedName ] ')'
;

AuthUser: 
	name = ID
	 ('{'
		attributes += Attribute*
	'}')
;

Model:
	persistent ?= 'persistent'? name = ID ('extends' superModels+=[Model|QualifiedName] (',' superModels+=[Model|QualifiedName])* )? ('{'
		attributes += Attribute*
	'}')?
;

Scenario:
	name = ID
	('GIVEN' (givenRefs += GivenRef)* )? 
	'WHEN' whenBlock = WhenBlock
	'THEN' thenBlock = ThenBlock
;

GivenRef:
	scenario = [Scenario | QualifiedName] (times = INT 'x')? (excludeGiven ?= 'excludeGIVEN')?
;

WhenBlock: 
	action = [HttpServerAce|QualifiedName] 
	dataDefinition = DataDefinition
	(authorization = Authorization)?
;

ThenBlock:
	statusCode = INT 
	('response' 'shouldBe' response = DataDefinition)?
	('persistence' persistenceVerifications += PersistenceVerification*)?
	('verifications' verifications += Verification*)?
;

PersistenceVerification:
	name = ID model = [Model | QualifiedName] expression = PersistenceVerificationExpression
;

PersistenceVerificationExpression:
	SelectByUniqueAttribute | SelectByPrimaryKeys | Count
;

SelectByPrimaryKeys: 
	'selectByPrimaryKey' '(' attributeAndValues += AttributeAndValue (',' attributeAndValues += AttributeAndValue*)? ')' 'shouldBe' expected = SelectByExpectation
;

SelectByUniqueAttribute: 
	'selectBy' '(' attributeAndValue = AttributeAndValue ')' 'shouldBe' expected = SelectByExpectation
;

Count: 
	'filterAndCountBy' '(' attributeAndValues += AttributeAndValue (',' attributeAndValues += AttributeAndValue*)? ')' 'shouldBe' expected = INT
;

AttributeAndValue:
	attribute = [Attribute|QualifiedName] ':' value = PrimitiveValue
;

Verification:
	name = ID
;

SelectByExpectation:
	object = JsonObject | isNotNull ?= 'notNull' | isNull ?= 'null'	
;

DataDefinition: 
	{DataDefinition} 
	('uuid' uuid = STRING)? 
	('systemTime' systemtime = STRING pattern = STRING)? 
	(data = JsonObject)?
;

Authorization:
	'authorization' username = STRING ':' password = STRING
;

Attribute:
	unique ?= 'Unique'? 
	primaryKey ?= 'PrimaryKey'? 
	notNull ?= 'NotNull'? 
	list ?= 'List'? 
	(type = Type | model = [Model | QualifiedName])
	name = ID 
	('references' foreignKey = [Attribute | QualifiedName])? 
	notReplayable ?= 'notReplayable'?
;

QualifiedName:
  ID ('.' ID)*
;

WriteFunctionType:
	'POST' | 'PUT' | 'DELETE'
;

ReadFunctionType:
	'GET'
;

Type:
	'Integer' | 'String' | 'Float' | 'Boolean' | 'DateTime' | 'Long'
;

JsonDateTime:
	dateTime = STRING pattern = STRING
;

JsonObject:
	{JsonObject} '{' 
		(members+=JsonMember)?
		(',' members+=JsonMember)* 
	
	'}';

JsonMember:
	attribute=[Attribute | QualifiedName] ':' value=JsonValue;
	
JsonValue:
	JsonObject | StringType | JsonArray | BooleanType | NullType | LongType | JsonDateTime;

JsonArray:
	{JsonArray} '[' (values+=JsonValue)? (',' values+=JsonValue)* ']';
	
StringType:
	string = STRING
;

BooleanType:
	boolean = JsonBoolean
;

NullType:
	null = JsonNull
;

LongType:
	long = INT
;

JsonBoolean:
  'true' | 'false';

JsonNull:
  'null';
  
PrimitiveValue:
	string = STRING | long = INT
;

/******* S.D.G. *******/
	
	

